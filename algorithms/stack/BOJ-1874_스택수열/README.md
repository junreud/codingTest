# 📚 BOJ-1874 스택수열

## 🔗 문제 링크
[백준 1874번 - 스택수열](https://www.acmicpc.net/problem/1874)

## 📝 문제 설명

스택을 이용하여 1부터 n까지의 수를 차례로 스택에 넣었다가 뽑아서 특정한 수열을 만들 수 있는지 확인하는 문제입니다.

### 입력
- 첫 번째 줄: 수열의 길이 n (1 ≤ n ≤ 100,000)
- 다음 n개 줄: 수열의 각 원소

### 출력
- 수열을 만들 수 있으면 push(+), pop(-)를 차례로 출력
- 만들 수 없으면 "NO" 출력

### 예시
```
입력:
8
4 3 6 8 7 5 2 1

출력:
+
+
+
+
-
-
+
+
-
+
+
-
-
-
-
-
```

## 🎯 핵심 아이디어

### 1. 스택의 특성 이해
- **LIFO(Last In First Out)**: 나중에 들어간 것이 먼저 나옴
- 1부터 n까지 **순서대로만** push 가능
- 언제든지 pop 가능 (스택이 비어있지 않다면)

### 2. 알고리즘 접근법
1. **현재 넣을 수 (current)**: 1부터 시작
2. **목표 수열의 각 원소**에 대해:
   - 목표 수가 스택 top보다 크면: current부터 목표 수까지 push
   - 목표 수가 스택 top과 같으면: pop
   - 목표 수가 스택 top보다 작으면: **불가능!**

### 3. 예시 과정
```
목표 수열: [4, 3, 6, 8, 7, 5, 2, 1]
current = 1, stack = []

1. 목표: 4
   - 1,2,3,4 push → stack = [1,2,3,4], current = 5
   - 4 pop → stack = [1,2,3]

2. 목표: 3  
   - 3 pop → stack = [1,2]

3. 목표: 6
   - 5,6 push → stack = [1,2,5,6], current = 7
   - 6 pop → stack = [1,2,5]
   
... 계속
```

## 💡 주요 학습 포인트

### 1. 스택 시뮬레이션
- 실제 스택 동작을 코드로 구현
- push/pop 연산의 순서와 결과 추적

### 2. 조건 판단
- 언제 push해야 하는지
- 언제 pop해야 하는지  
- 언제 불가능한지 판단

### 3. 효율적인 구현
```python
# 핵심 로직
if target > current:
    # target까지 push
    for i in range(current, target + 1):
        stack.append(i)
        result.append('+')
    current = target + 1

if stack and stack[-1] == target:
    stack.pop()
    result.append('-')
else:
    # 불가능한 경우
    return "NO"
```

## 🔍 시간복잡도
- **시간복잡도**: O(n)
- **공간복잡도**: O(n)

각 수는 정확히 한 번 push되고 한 번 pop되므로 총 2n번의 연산이 발생합니다.

## 🚀 확장 문제
- **BOJ-9012 괄호**: 스택을 이용한 괄호 검사
- **BOJ-10828 스택**: 기본 스택 구현
- **BOJ-17298 오큰수**: 스택을 이용한 다음 큰 원소 찾기

## 💭 주의사항
1. **순서**: 1부터 n까지 **반드시 순서대로만** push 가능
2. **불가능한 경우**: 스택 top이 목표보다 크면 절대 불가능
3. **메모리**: 최대 n개의 원소가 스택에 저장될 수 있음

---
**난이도**: 실버2️⃣ | **유형**: 스택, 자료구조 | **핵심**: 스택 시뮬레이션