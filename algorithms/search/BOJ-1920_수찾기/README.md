# BOJ 1920 - 수 찾기

## 문제 개요
N개의 정수가 주어진 배열에서 M개의 수가 각각 존재하는지 확인하는 문제

## 핵심 포인트
1. **해시 자료구조(Set)**: O(1) 평균 탐색 시간을 위한 set 활용
2. **탐색 최적화**: 선형 탐색 O(N*M) → 해시 탐색 O(M)
3. **메모리 vs 시간**: 추가 메모리(set)로 시간복잡도 개선

## 주요 학습 내용
- set 자료구조의 특성과 활용법
- 탐색 알고리즘의 시간복잡도 최적화
- `in` 연산자의 자료구조별 성능 차이

## 알고리즘 접근법
1. **Naive 접근법 (시간 초과)**:
   ```python
   # O(N*M) - 각 M에 대해 N개 전체 탐색
   for num in m_list:
       if num in n_list:  # 리스트 탐색 O(N)
           print(1)
   ```

2. **최적화된 접근법**:
   ```python
   # O(N+M) - set 생성 O(N) + M번의 O(1) 탐색
   n_set = set(n_list)
   for num in m_list:
       if num in n_set:  # set 탐색 O(1)
           print(1)
   ```

## 자료구조별 탐색 성능
- **리스트**: `in` 연산 O(N) - 선형 탐색
- **set**: `in` 연산 O(1) 평균 - 해시 탐색
- **딕셔너리**: `in` 연산 O(1) 평균 - 해시 탐색

## 시간복잡도
- **시간복잡도**: O(N + M) - set 생성 + M번의 탐색
- **공간복잡도**: O(N) - set 저장 공간

## 난이도
⭐⭐ (실버 4)
