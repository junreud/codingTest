# BOJ 2164 - 카드2

## 문제 개요
N장의 카드를 1부터 N까지 순서대로 놓고, 맨 위 카드를 버리고 그 다음 카드를 맨 아래로 옮기는 과정을 반복하여 마지막에 남는 카드 번호를 구하는 문제

## 핵심 포인트
1. **deque(덱) 자료구조**: 양쪽 끝에서 O(1) 삽입/삭제 지원
2. **큐 시뮬레이션**: 맨 앞 제거 + 맨 뒤 추가 패턴
3. **효율적인 회전**: `rotate()` 메서드 활용

## 주요 학습 내용
- deque의 특성과 활용법
- `popleft()`, `rotate()` 메서드 사용
- 큐 기반 시뮬레이션 문제 해결 패턴

## 알고리즘 접근법

### 1. **문제 패턴 분석**
```
초기: [1, 2, 3, 4, 5]
1단계: 1 버림 → [2, 3, 4, 5] → 2를 맨 뒤로 → [3, 4, 5, 2]
2단계: 3 버림 → [4, 5, 2] → 4를 맨 뒤로 → [5, 2, 4]
3단계: 5 버림 → [2, 4] → 2를 맨 뒤로 → [4, 2]
4단계: 4 버림 → [2] → 종료
```

### 2. **구현 방법**
```python
# deque 초기화
dq = deque(range(1, n+1))

while len(dq) > 1:
    dq.popleft()        # 맨 위 카드 버리기
    dq.rotate(-1)       # 맨 위 카드를 맨 아래로 (왼쪽 회전)
```

### 3. **왜 deque를 사용하나?**
- **리스트 사용 시**: `pop(0)` → O(n), `append()` → O(1)
- **deque 사용 시**: `popleft()` → O(1), `rotate(-1)` → O(1)

## deque 주요 메서드 활용

### 1. **생성과 초기화**
```python
dq = deque(range(1, n+1))  # 1부터 n까지의 deque 생성
```

### 2. **핵심 연산**
```python
dq.popleft()    # 왼쪽 끝에서 제거 (맨 위 카드 버리기)
dq.rotate(-1)   # 왼쪽으로 1칸 회전 (맨 위를 맨 아래로)
```

### 3. **결과 출력**
```python
print(dq[0])    # deque의 첫 번째 요소만 출력 (숫자만)
# print(dq)     # 이렇게 하면 deque([4]) 형태로 출력됨
```

## 대안 구현 방법

### 1. **rotate 대신 직접 구현**
```python
while len(dq) > 1:
    dq.popleft()           # 첫 번째 카드 버리기
    top = dq.popleft()     # 두 번째 카드 꺼내기
    dq.append(top)         # 맨 뒤에 추가
```

### 2. **리스트로 구현 (비효율적)**
```python
cards = list(range(1, n+1))
while len(cards) > 1:
    cards.pop(0)           # O(n) - 비효율적!
    cards.append(cards.pop(0))  # O(n) - 비효율적!
```

## 시간복잡도
- **시간복잡도**: O(N) - N번의 O(1) 연산
- **공간복잡도**: O(N) - N개 카드 저장

## 관련 개념
- **요세푸스 문제**: 비슷한 패턴의 수학적 문제
- **원형 큐**: 회전하는 자료구조의 특성

## 난이도
⭐⭐ (실버 4)
